# git-cliff ~ configuration file
# https://git-cliff.org/docs/configuration

[changelog]
# A Tera template to be rendered as the changelog's header.
# See https://keats.github.io/tera/docs/#introduction
header = """
# Changelog\n
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n
"""
# A Tera template to be rendered for each release in the changelog.
# See https://keats.github.io/tera/docs/#introduction
body = """
{% if version %}\
    ## {{ version | trim_start_matches(pat="v") }} - {{ timestamp | date(format="%Y-%m-%d") }}
{% else %}\
    ## Unreleased
{% endif %}\
{% if previous %}\
    {% if previous.commit_id and commit_id %}
        [{{ previous.commit_id | truncate(length=7, end="") }}]({{ previous.commit_id }})...\
            [{{ commit_id | truncate(length=7, end="") }}]({{ commit_id }})
    {% endif %}\
{% endif %}\
{% for group, commits in commits | group_by(attribute="group") %}
    ### {{ group | upper_first }}
    {% for commit in commits %}
        - {{ commit.message | split(pat="\n") | first | upper_first | trim }} ([{{ commit.id | truncate(length=7, end="") }}]({{ commit.id }}))\
          {% if commit.footers %}\
            {% for footer in commit.footers -%}
                , {{ footer.token }}{{ footer.separator }}{{ footer.value }}\
            {% endfor %}\
          {% endif %}\
    {% endfor %}
{% endfor %}\n
"""
# A Tera template to be rendered as the changelog's footer.
# See https://keats.github.io/tera/docs/#introduction
footer = """
{% for release in releases -%}
    {% if release.version -%}
        {% if release.previous.version -%}
            [{{ release.version | trim_start_matches(pat="v") }}]: \
                https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}\
                    /compare/{{ release.previous.version }}..{{ release.version }}
        {% else -%}
            [{{ release.version | trim_start_matches(pat="v") }}]: \
                https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}\
                    /tree/{{ release.version }}
        {% endif -%}
    {% else -%}
        [unreleased]: https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}\
            /compare/{{ release.previous.version }}..HEAD
    {% endif -%}
{% endfor %}
<!-- generated by git-cliff -->
"""
# Remove leading and trailing whitespaces from the changelog's body.
trim = true

[git]
# Parse commits according to the conventional commits specification.
# See https://www.conventionalcommits.org
conventional_commits = true
# Exclude commits that do not match the conventional commits specification.
filter_unconventional = false
# An array of regex based parsers for extracting data from the commit message.
# Assigns commits to groups.
# Optionally sets the commit's scope and can decide to exclude commits from further processing.
commit_parsers = [
  # bracketed scope: [Scope] fix / fixed / bugfix
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*fix\\b", group = "Fixed" },
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*fixed\\b", group = "Fixed" },
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*bugfix\\b", group = "Fixed" },

  # filename.ext - fix / fixed / bugfix  (common separators - : – —)
  { message = "(?i)^\\s*[^\\s/]+?\\.[A-Za-z0-9]+?\\s*[-:–—]\\s*fix\\b", group = "Fixed" },
  { message = "(?i)^\\s*[^\\s/]+?\\.[A-Za-z0-9]+?\\s*[-:–—]\\s*fixed\\b", group = "Fixed" },
  { message = "(?i)^\\s*[^\\s/]+?\\.[A-Za-z0-9]+?\\s*[-:–—]\\s*bugfix\\b", group = "Fixed" },

  # filename-like token - fix / fixed / bugfix (no extension required)
  { message = "(?i)^\\s*[^\\s/]+\\s*[-:–—]\\s*fix\\b", group = "Fixed" },
  { message = "(?i)^\\s*[^\\s/]+\\s*[-:–—]\\s*fixed\\b", group = "Fixed" },
  { message = "(?i)^\\s*[^\\s/]+\\s*[-:–—]\\s*bugfix\\b", group = "Fixed" },

  # conventional "scope: fix/fixed/bugfix"
  { message = "(?i)^.*:\\s*fix\\b", group = "Fixed" },
  { message = "(?i)^.*:\\s*fixed\\b", group = "Fixed" },
  { message = "(?i)^.*:\\s*bugfix\\b", group = "Fixed" },

  # plain "fix", "fixed", "bugfix" at start
  { message = "(?i)^\\s*fix\\b", group = "Fixed" },
  { message = "(?i)^\\s*fixed\\b", group = "Fixed" },
  { message = "(?i)^\\s*bugfix\\b", group = "Fixed" },

  # additions: add / added / support
  { message = "(?i)^\\s*add\\b", group = "Added" },
  { message = "(?i)^\\s*added\\b", group = "Added" },
  { message = "(?i)^\\s*support\\b", group = "Added" },
  { message = "(?i)^.*:\\s*add\\b", group = "Added" },
  { message = "(?i)^.*:\\s*added\\b", group = "Added" },
  { message = "(?i)^.*:\\s*support\\b", group = "Added" },

  # removals: remove / removed / delete
  { message = "(?i)^\\s*remove\\b", group = "Removed" },
  { message = "(?i)^\\s*removed\\b", group = "Removed" },
  { message = "(?i)^.*:\\s*remove\\b", group = "Removed" },
  { message = "(?i)^.*:\\s*removed\\b", group = "Removed" },
  { message = "(?i)^.*:\\s*delete\\b", group = "Removed" },

  # --- Additions: bracketed scope, scope:, token - cases ---
  # bracketed scope: [Scope] add / added / support
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*add\\b", group = "Added" },
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*added\\b", group = "Added" },
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*support\\b", group = "Added" },

  # conventional scope: "scope: add" / "scope: added" / "scope: support"
  { message = "(?i)^\\s*[^\\s:]+\\s*:\\s*add\\b", group = "Added" },
  { message = "(?i)^\\s*[^\\s:]+\\s*:\\s*added\\b", group = "Added" },
  { message = "(?i)^\\s*[^\\s:]+\\s*:\\s*support\\b", group = "Added" },

  # token separator: "Filename - add" or "Token - added" (accepts -, :, en/em dash)
  { message = "(?i)^\\s*[^\\s]+\\s*[-:–—]\\s*add\\b", group = "Added" },
  { message = "(?i)^\\s*[^\\s]+\\s*[-:–—]\\s*added\\b", group = "Added" },
  { message = "(?i)^\\s*[^\\s]+\\s*[-:–—]\\s*support\\b", group = "Added" },

  # --- Removals: bracketed scope, scope:, token - cases ---
  # bracketed scope: [Scope] remove / removed / delete
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*remove\\b", group = "Removed" },
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*removed\\b", group = "Removed" },
  { message = "(?i)^\\s*\\[[^\\]]+\\]\\s*delete\\b", group = "Removed" },

  # conventional scope: "scope: remove" / "scope: removed" / "scope: delete"
  { message = "(?i)^\\s*[^\\s:]+\\s*:\\s*remove\\b", group = "Removed" },
  { message = "(?i)^\\s*[^\\s:]+\\s*:\\s*removed\\b", group = "Removed" },
  { message = "(?i)^\\s*[^\\s:]+\\s*:\\s*delete\\b", group = "Removed" },

  # token separator: "Filename - remove" / "Token - removed" / "X - delete"
  { message = "(?i)^\\s*[^\\s]+\\s*[-:–—]\\s*remove\\b", group = "Removed" },
  { message = "(?i)^\\s*[^\\s]+\\s*[-:–—]\\s*removed\\b", group = "Removed" },
  { message = "(?i)^\\s*[^\\s]+\\s*[-:–—]\\s*delete\\b", group = "Removed" },


  # tests and other categories
  { message = "(?i)^\\s*test\\b", group = "Fixed" },

  # final catch-all (must be last)
  { message = "^.*", group = "Changed" }
]
# Prevent commits that are breaking from being excluded by commit parsers.
filter_commits = false
# Order releases topologically instead of chronologically.
topo_order = false
# Order of commits in each group/release within the changelog.
# Allowed values: newest, oldest
sort_commits = "oldest"
